Our project is divided into a front-end Android application and a Back-end PHP server which is connected to a MySQL database and communicates with the Google Cloud. On the front-end, we created the interface that the user will interact with. It consists of a calendar with events for each day and allows the user to create, update and delete events. Once the user performs an operation on an event, a request is sent from the client to the server. Once the database query is finished, the server will send a JSON string to the Google Cloud and the Cloud, in response, will send a push notification to the client. When the push notification is received, the Android app parses the JSON string and populates the calendar with the events. For example, if a user created a new event, the Android application sends a request to the server with all the event information and the server will insert the event into the database. Next the server will send back all the events for that day to the Google Cloud, and the Cloud will send a push notification to the client. When the client receives it, it will create an event on the appropriate day with the appropriate information. So in this way, the client has no access to the database. This may seem like an unusual architecture choice since a local database would simplify the process. The reason why we chose to design our project like this is so that we could make the client side much lighter and do all the heavy lifting on the server side. This also protects the data as clients cannot directly access the database, but must have all queries parsed by the server before reaching the database. Lastly, we chose to only keep a remote database so that public events (although not implemented) would be able to be distributed to many users’ calendars’. So if a professor put up a deadline, every student in the class for example, would receive push notifications. For this reason, we decided that we had to use a remote database rather than only local databases. Also, if we had created both local and remote databases, we would have to deal with syncing, which we did not have enough time for. Overall, although this creates some minor problems, this architecture greatly simplified our work and worked successfully.
